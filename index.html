<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Site</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Site</p>
                        <p>Please enter the password to access this site.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4afff7404adebc2e1261c1f434afd90664dd687cda0ca6a142acc2b02b4d6d7f6eb145cb3ddb9c79c058bbffafbe7bfcb8da1c591db89e84f5858d93682532415df5ad2bb4ded8699fa1f98c279e3347bc8dee7886b0af79343a2a3025c19bb5df421e5e85700f8c2015718c834938f3a32c7bec1ca78cc0e7ddc37d39fff4d225f588328a8e1135b9e4f1fb77b52e7d2b024bc778cbdb8f7b953f419c48854be48d547d90b1db2ff08503576082d9584f7962b2e5c2cd7bbca3b0de7d00bfb42773913cd02933fbfb14863992931f50605776d1c58573cdd3a3959365722ddd68a837545e2ab961c8cb667d66c014ff4420afee549490dcb393f93fed6daa81f5e61d04484e729e3993b071810feaf71983a6903471b9cffde3b8626c217e8c487b96ef8b96f966848421532f633e05b0d69167b7ade550141c5197b35fe7371f9c193b4c01693ed05403593024efca70b459488d9e5be9c2d30aa610bcdb53e53b10f636acffb5b5fa875111a3ec73df86e6956119a8c6377cb9db02ccc0e107fcda4245bd11cacc4ef3734e01d4301e4ec08b99c3b80b273f92f38764d79ae79a467dd869c7217ecbfcbb7aac35ab6df871dfb3679674bfb7cdcea0916b1da3ade73ef03d37cc1578755ccfa5e057c03eeefa333c12fa1b6a793fe63e98de86987bca599560977367e33c97abfc0aafceb9b4dc06480cee6602f51165f5d1d32b560d78d234a8ccb44f0c9d79a8350a8d828ed2202863fec186472a1c3cc189a480c35ae567d3934f9b94bb4be12781a5a6053a71d428d2ecb4cc630be3ea32197b2d7e265ae646df29e22b14b80a7400dcc56c25eef521c2c2d6dfc8666b9b8ead925f0b22fc5d47a474cf713266adff3419deff11960f8b881d830aeae1bb170e14179e44d0434d38cb41545012877854c1737d102ccdfc3f2e54c6934dbc29fc040074567499164ae72bfd3a04f28c6d52798d6fa842cd920fdff6b8d401ed7ef20434826881b158b4020e821e917ebd9d3daa808df7f6ab2af44ce2fa0aedcaa9e82c3491105bd747ee24df30ccbebaa05d6fe08a2010e2a20bd3cc9f15b64674da910910f51a8a74996e0ecba1c582c9cba20a4c0bcca2613c0106d386156ca48b56b4361d36f0101699a60fe7b7edc6c4ff97dc1300404ca779a02ca3de3656fd64eb7ab3502605c963ee24002991af589b41145ff2d1013be904f8ff10943b1ed144b6cc4f26f3a3ae8f316e893c2cda820cbabfcf582944ea148cf52f36036a8cae4977e879cb8b407a525c2278e7d689cbfba9dca607df793831b80a320dc0c33b7d8527cf6b18831e0819335247afa2c0194d317d745ff7e375861fda89ed50501c223bf0c217afa9b4e1fdc13a0510591de67fc7bc6f1eb02079c6a896ec009d160b1855fe454caf142e63709b71f577e9aef1285f0782979e6ac5d235b6c3a0acf4c8cdd4c70fb9697a2943b18bfc9f049eba9981f0b46a8d05ab13c11b4c2455a46fb99798d6c8857eb10d69621d87da06dcaf26912ef354e95fc975fd91d6a9ed68730b32789da6cb70b1638d9d2f58bc72fda64e232c3d55378636751061c8e0ff0c7d3f18a932b4d0cce1a75e45df483ff51f1ff1d8091f00d8cf49ce2d669e934567b838a49d2bfb0ec4b47bf688f384584544372ab069c0a66e8c0823697077f5c0805e61334014f62d8482105843ec11d8ec6f9581a14a03305bfeab57c270a1107b9f48e1c15d38f81c8cbd5af7fcd4d0ab25a4ea1097ec57d433f7736350551089b4503415af7670eeb06a3c473a65c1d659179163250a5fbbc19cbae472b410486015fd3df5ccaa1703b16abbeaceaf8e0e667679643e841a8e8a14f8f657eb5405c4b387fb6f801732c1489785facb41d9c75d47cd4fa5b2034cac171c3cb459cecef59622ea8354dbd44c2aa71bf5e549edb4ddaffbd6b86e3732a366720f0a73adc22fd978fb2f9295d1e7e687183fb8fa5f10916119575572695b93aea6bb330b153ab0fa89016f299d4ee06a0ac7c568f4e4220c9c6acbe2d40f26ffc0b8646d99038dd2259eb76edcf44bf0abe181e9470444fd301bfd91245d85e23d97caa8feb54abb9311ffd9f0d00ae5364ab3ec1b822e969a4ed23b7105244b0cb15cd5b1c79353faf02acaf580fac4c04eaf6eb3d5e8db006e6babfa426002b36291a7f40ddce3deaf63b596bf8959e4f4c5fc02420bbf89ec9e049c84aa32898cfd8086b0df7271b4b6c5249c79f40de0af0b8abbd3b9e1411d6732914cae3f67006b5702927e3e3969957d1bbed356504c2201fc48cc4b96bf3fb59346cd5bd6abdd6e0d2a8e20f0d181a2539da76ad4aec3765c132a322d78af1888cb2659922f3f9735ce51dd01a8d49673fa1943b2bd0e0f9e34077711a240db7f48130032a9ea4f44905e4c511656e002da88be961455725085f7d8bf6997b062a226ad1c043f57aa065d25df911cc9786f1994f7de2c31dc611de4f8850890f63aa914ad9aca9443c5b08813d8be14085b6a6852cc7c32f1aa100ac13699022bcf21d4e33a7539daa42ad8ca1ca1e8baa906a61ae5d76c7958fc35938146fbc583c8052b42ff7f48bbd76a66c466c87b45d5a99798cddfba2e0c7a1fcda6fe6035b8f9eb18252be629506fd427749106c45f87c6a2091e318969d7140f67d3ac9e08c1c24e04c5eba028752d85ff4057e57443f2068cda3b597da16a6ed6b7a077e1774f4133bf7052748e6ddddc85f06b87d24921850d09597c5109c8bece2210388bd0a0cded7a01ebe85aaef1800da1689d2998bcccf1145c94577a99abd913c12e9d6aeaee83512234799585f499e834354a27f713020704e91c64e2175f9d7e7e34718e81774b4063a72c614ce917ef6a44106ce7462584a8c32564ccd7186e2d7fe978180e3daba1db1e08eb4ea692afe51c3ac204550794d7ddebbb671b7e87dbcc3f8a433a8b30eb420df74408a29d122bd7b9893396c775d1a5e335ea301cc1021047655bb294d11af4de8cdbcc8f1046dbabdfe44b749dfcfa545aa497ef80a45f458e2ce56e2faad3028301fea29176e5d5b0b0cb0b53a047ff53d25be405e803df510682b78926539c4493ec17a8fd1b86358040d96e52577283d1a356ba90c94c87386b2b482fdd9d1a7dae13f318f376ee953633aab7c77101165b0babcec3a3b67a2aec03e61a9dfdd210924808b09f7dc663c55cf5078c9c047eb9ba7419dc6b94f91a59a59bb4154d615a062dc207739d435b037edb1fe0e01d7ac2d737c2155825d2a383cbc4c417e03b537cbecf4b16a22e380e736ef2633d6ac31c0edcb687473154d55b1caf3d1061f2f0f63d85e5adb8d42ec1e22a13b3b4f218e925cafa3b0845cb35386b6392ac08a875dd204afea136c6ad613f8d8f2f6150545c7f56bea7d12e2a28586407879cc260c455007d3f2f9ba01a53a05c8f9cbd5667bd4a8b51e7de8bf15c693d74474aaca6b999e02c1082c3e9f65d7669e2a3883ecf977e22d8b5b76104db6f990e985dba28ca39ba12967ad691c11b97bd56c7a9e6e96d248eebb94e5be1d1415eb87bb05a6900241c9ce14494192779dd9120faff4be67c40c4981e55837814f4d8bf93e074b630d7a9989ebee4fcd44b3dde4193f8598e7222161facc841a2e2fd018ece33042536991349cedf0c9d85c30f9301ef3cbaaa705dcaac93a22fdfd783c79edbbffd3195a94b3fa6683a70aab27d87daab3b04759cccec3fdd9dc3df7640af7ddceb765ada7d56c21bc22711d2cd7f206686e120ba14c0c3ebfc3aea0e489a85bd4ee28ecb0a5b2dd55cbbce6ab8250084187195ee1d86e84b726de9b7d5c9cd1819284842b091c27b56b8b1c09cfab19647ba9dd6ccace800d4b2edf1b6e6503fcc547b2cf88918ae97264147ab2bad1e22ddf368c67c736b4321cd4e0a369b2d156e6e11757155f64016f5e1d308a3e43118110ddc59e1aa600ef95b62d65e21c7f021b73a7049bb1925e1d3312c91be59aadbc91b2ec15054d9f26265f70210bb2ea0937d1e81499504a4250991b9532bce4c58e9e1a83c80fe524d30a0833edfedbb39d4e0278a64ee813d777726c04b5a161014bd84e4d2434d66d2cba4669be88bfa862a6ccfeeab11f2229846551582a0180eb9c23fa514d8746cf896237da70b69f46b8869ab9d48fc845de6c5015ebdf02cf1e59812bee5e4cb9fc4191a478e779dd0488b973a4255eaf1a14ce4847c36e248075e1a9ab066d8275f435dbc2904a9e7cc1d71e6b426daf75424dbc7740994dc4e63624a746048a6f2389b6a7d01a7c991e02584cc73bd82702456913c02ae4fef984e10dbeaf25107d47cba348418f5e0ceeebca7a84be17f8a352c5640cf0d26be2e0756160ee51e2d16b6720d1b3b34cc7db6b39b7cde5b40a5dec3c669e781bc624197295495c4bdf291fb32bda56cb7dabb234e85919c0ed41049b285d9cfa7875928da580198dddc7ff6a51782bda6dd9ade14335fe220e2f086e6e09497c4c544962e89693f44b3eb68cf02eb11962748a5a731f3faaf1f8cde17f708ece827a60a5b7a01abffe59ac607a436f0db61701893e85989733fc763602df335543dc23b49da09ca424f2a2213dcb21e4d2408d4251bb8395bd65e1de51280a6d43fb0bed82d9ba14f61465f2882917a2dd2c593675dafb37fd1e802de1b3b2a900b874be9b53fa455664f151cac7f9648a22d9f3631850e411f8d07686ace969919ae5cd091fb56fc22867053719d55316694606307c31a83ad5201222f20e39aea7415a3c39fce319ddaa3714dc08bc6fdcf90b2366744bead932f2420415d88e96a56c2bc5330327cb3fabf8cfa4dc6c5d38fe7b6956c3c90432d9e81e47dd915f1d520f7fca25ab40eee317951c8a83e590996c118b82cdf474844846d89923ea9e69c78d594eb9cab888be3478c1ee29be9cb9e140d94e145f45040c954357d1d94b9a3245ae138b48454fdaae3818c682c7d82469a84f22d3e59e990ea6f3f85f4a84f0c7d36aefd73063822c78bcb9f0c0cde9412d01ca36dd9c313a492eff67a6fe70b939fd0a54d1a16217b82758ea052aa619b229db617973e2943b1d89180897d79ce2a4534e37bfc62eb0ba1be9f3436620996e828cb79b3bf6547b80f395705f4901135337a58a890b8629b4498ff1478e4bce3e5ee12ee1e3e54cd0a6a4bdbb10b76d92df3a335617d53af4f1b7938b9e62e41f9a0f2f8267858897f312510ca62e69f143238e795a25b13cfb49863be873edb7bfb4cbcad4b60138dd87f420a83a0116333728ded709ae9910d25ccbb9394307aa440ade350cdd679ad96d3e72dead1f0cc85c524e3795fb02b40ed99b019c63bb83d3d7ef798cfe8fd80a21692e2e7560237419431bded3b03908431bfe9de571c1dc436e14f2e517c0ca2b65f00103dae0c3c18eb0f79a304baac69cf0b3a64b61b90c593389addae273a06638b4373c067d8e80486c8e88b91a982edf2a673d0e5e77595081fada134d60b8c4d3a51ac6e9f9d04d7506cc96b6dd3a91d1173dbd5cedf7b852b042e36cfe47d88c2db42abcaaeb52fb6b664e6f78782da49bc90abb3703e9f1c19062094f6e98fb40a100e04f1a832580936cdb7593224baab42c1607ce0ee1a831c4542950a5c3325a6545382ffc60500c79078deb4e9150d804d7a783e10269275b20f1d1e8b7dd2fa742b288ee8f384f496789bbb3a0a4e03e4e9cc9f3f68b069d8cb1e046d43ebafe265dece4bf94bbc5c1789afadb1457e20f9fe1bb8a1d1189f990048f0db9a329c4f16cf2e7cba50b54862cdfeb7fafe6ff20e9c6141c881fbecc46f5d5dc8886dd5b5bb6c8d31bc583aaddb257f3943874d73d925bcd730630e4311ece28684fc574dcdcbed51287e9b3d3c8b5a6403d67b9ae5711b1e256bcd42e273aff9ea0f4d33b515827985feab948e30da8f6854a043f6502177566c663eb0011d60c534e57b2723e0cd4a963644e114c6e966312299d98c7954a155a12702ac35ddb3ddaf28cb089ee12ea6d878768324610226d6c994bcdf31d7fd97d6a9cd95c692f3bfc8382dcca5af6b313547cabb82d2a0dc43e0a592fbf88adf85d62a4b4ac1a053165486ef0d3d191baadd3fbf745ba29fe512b5fac411be66caa63349388146e4e475425865676724df2c644bff706453f06a95a9e86823bee635004393cd0010efd0a0fa4bbe1965a2c6ae962ca890b0d7f399a5bd8ff2164d4fab53f06e2d92569adf9113eb70a001153f5557f4ce331a6758c708c97adc6b413b1400b667f8ea88af569b99828540944de8579aedb898e9c190caedd290d53e6bc55908bbf95b8d31e50e6337467fdf4fa6919db94be52de914bfb2ffe8aa6a3f9c356b285b19c81a3768af402dbcc016d19c0eeefc8b87f4edce00e3860220cfe4a35e3dfadd8396283d6205783b31484404328935dd21fe3c4b99672076981890e997e5cc96a77be660181e76ac972af3be2ec1831437b1b16374a94aa27fdfd46b796af5c1b8739b763e093c110c717c41a05fbd2a2a20b5272d89fce2f4b54e8bde9efe9fad6e45f6c64d208959a86aa51e50e7fe8dccc7a135c71b99605dea7a0408022da22b160a445c8e1ffeb4a2fc5b3c8a60e07d37fd13f8635352a458bcd0c8907dc4e5deff8be28bc8c2c8f22ae01848c91778688b7d12534e39f65f7a70ed16d05f9cd89245dae4bb5493354731f23d9e1e544fa901e6315bb5cbd496a51b990df2c6a667594c7ead0457f144427f0cfd5d22b330ab2c0d06d460f35640dc3638a935a1bdd8bda16fb93169a957fb37a7eeba1adfbd82e46832007de2a83449d653a6a3f8949fa239e4ad6c07b8abc2b978bb7c9f6008559f6960f2a53aa761e66f24c660ba259e9a962be1081895c06e4f6adce7f097cfbf96a11d7a90ad488770017a1c77a5c7518f8a4b09e9b1aba1c1e408cffd73988694b25e27adbcc83b16c8ff0cfcc870c9cd203a2fd9e987e9312d81062e83144978f267feda8d64e0dc0518fb84cc73dfcb6daee5be96880f7059ca3b420d42356c4e90c580f52b9f582c5d819db442167c85d83e6d47def1412ed298a6fd6f8c5e6f70c0e8586de22a4c4f2d118bcf4bca84f49d94c7ec6d5e23d5b120150b924569304c55ff7f474b30883a3105ef3648b49131fa0a1feaeaa49938e8bd956c3f6b7889606d30ef34ddeb07f321054cf20b53e8bfd29d6ce1dfa41c5a759b1c3de0571dc721537ac89db883922441068bc81c5849beb41ba159782ea3df7827eaa7fcf4e6f307585ab1ee5b68fdacdb09369ae3d0221da42a6857c64d63c3c892180a3803077c2839cae4a2e5f1b39024d4697f5c7cbc3d8a4599eb156dba32b3bf8f85a10617fee0690b13bef04f884ba6f4ef865ace0460ad6ee8b5f0a6a0ef7dde545a6a88fd09a852cd45a2f31ede8bf7c4231acf4e974f9e625eef17b2a750a77ab51dc164cd5e53ed708dfe9d90d75d37c1a456c9a372f7cfafa0698a5403c415e58721221cd70a50781d4728d9498a4793d504f0945a7d37af2ad4e75dad3cd155936ba08a0499d3ec7e13e40f2c7e620f2ca09a0c7a3aebddc6fdd820d86c2e7fded0ddb645d763cc7947723cc914c732489843a6e1d861b5e9d35d683e050c16232e3513e914aef24b331ca7941b5418d08b8b8e033cf433eef99b67d68a88aff1caf78150ebe934f625d83776fafb9aec22ca295dd7f33f33f1ba20e91d681bdb505e9d952164663f52afc77168f5c4da4343cf78ef7c28542b87d435190a50c5654232e11943459e11e44e1ef4b0cca5731f7827abc4659558d51ac7892d56c62bdf96bc4ef52201317d01d1492a1d60ecd13a0417eef13e836c0a1d7e0766c4de150ba6dfa798074558cad73d5a6b043d36f899dbe3323742a29e39d3f92553cc398adbce1deb3a91e639ee38971c212c83b11e3f240e3aed103a9e8e0ce291798f9fee88c9a11daf8655ef334aaf56d767e3dfb16a8a1212289af24e512f332fdeef7537523cb5bfc521deea67aaec58a55fbfc0d6dcd4050b4e809719f0a2585972aac2bf8ca9777f59411d196d8b1df883fbeab5b5a9730e436372ac49f5013b3e0edda135cf46f9d8575169d5278e1cca8b688666c029ab744797af89c19e99aad8d42965f254b1fdf724a2b3ccff2b88ca1473ee3a59bd094da6ee2f597ef874b171fbbd9f9043137ee1ca02ceb7ade43a1c137e86f121f0c2ce662a2fae68720db7347281dc3525ac712ce230c72ab888b670695333f15e1d00f8f26e8d761457f364f7d8deed5456a98a667f4516b5bb5d096c16dca9dfc4829e3c02a95ea111e0e12f185056993173f20fbbda7bc1f4ee00f9293fdba98666ad54484fa651454ac2314761de5b3b310cb1eeaa7ffe6db2b4cee419eabeafcb09bdb2e90df95386ccf83754762144385efd9c42e4b9b8720a181015b4a5f844d72eb8364f66ddc6eb408aad712bc593fead970827b5011f90839aad4903bef5cc2ea11e6fc65668b526de24d4efc457a4bdc2ace5bc5871f08c729eab04037059a54519ef0d5fa7729927fd0f133298cbb03219299fb9ba49edc47a27ab45bdb1fa5238586d71126ad04d7174567eac85774d5ce79f9f7a394aa8bd88858e9083e3813b60d10f9f9a34cbe5b64c6823285f7a54c17ac3bd735cdfe64497bd4a07e003c32479d4ebec5c44cd91943194f0b97e88f8b76e880ed4ed46f119a03b13502070c3f0201b1c0010f9bf3b3923ec97753a777d0fecbbcc22322dde4486c9461821293250f6bda4e87547489f4fe19c863008b161502969a704609f1fc2f34e3474755d1a9b697dea4babbc60cb835be5ef6903b8279d94fb7b243919efd77a3be08ff02d57498149b5e6df53b795dd8d705e30546f4e62754e28796dd3855a77ad54ec3ea0cf838170c4957dc97ebcb47371841768fbdab3b139d81bfe329fe85dcde47dfa9e3e5ba11910724340e8094ce38a4429e9113445925cd5d9b82eacb4f98c167e97292ccb3fee20f245155f309b6e359e698af424f2d5ef06e9dbd3fa63b42467f0ee2c7c947510cc1e455ec85e5fe407ecd0d491ca5422422a69063fa547142ab464413af0c583bdc66c49cdd3635159501b3fa6db73b24ddebfd259ce8b51151d5789e6fcc3aae48cd240259775b74a1b773dae59c6e20599a4f9c2acd0e9840a771a7a05021939758d4cb9b333277892072504e38f69ace554f3f681b999df8e9b3fa158ba0798895531ec258043d96b22c44087e5bf68a7bcece5df222f1d391ebe7b887cc6b61880a52f1d9f8b05ec7bef447def56d73f1a8c01a9148206841a14e415bb4c24b875092297c2c5260fe2a833dd8a323402907672a08a9601ccf9dfbd07d6e67c6ddb0a94ac113b9e6463a2e59610be001522f3cc1726525526ddbeece0c3cba8f19780dc12df1351f6d1e0757313512586ab5368c0829d6b8e0ba71f152e90625c6b68953dee7c762b89db477fa82b5f3184e61edb5e1cd2a4a4a2a36267555fbc8f153b6f3609336d709d0174f4a75df3bd58c2f31a62877acc351bdb1e4c974581b31a37c7a113747f7d23ee37ce3a78deaf2b85ed7dd4a6a7f07d39314ee7c03e18040f1f104eff62745e39e95189a9b617f9146142c0ed5ba88e3c509350d07854a81cdd037cd859149c8607526dbd6f9c7feb7432d72ae94e5a790b1e7f69c311b7df908acea4cdf36187c1b129100db3fb819527865fd45915e352359988c477fddcb399b3925bc79d95c879c385176598e999f65b5dc8fd9ac8fedf5f761b688ec894e1af452348cee35a89f3fc7ce8958ec3e45908a6871c5b3e9c4fe887a9bd85d6a3d22cd7df2c20e1334c3eea6f48273b0f80b06133aa5eea6979fbc832eab3e48def4703609a6b78da0d960b56de3551d3c706cb2f8ce873b4c0b3cb4c65f39b668d3418a1d1979d6739452e140cb8a7717e99df2df6e0533de683ec78404ae7e4005108aa9f62a568f37e3c643a6e8783bbf410213fe9539d57d92131762403ee16dfb5a090c8596ec8366fbcdda4e93e7a7b653fb7ebe04b2456629c825142851ef5a1af3dcbd72363c383496ececf9c0a902d606da7ab2b11f2b2854a2cebd694bc02d828d27f24e3b21319e07c67a87ec6ff0c9ffca0aede3ffc0e1247811eaed665957b4a30370386aba5ef2b0118414e6fb538109fea81946a5f78bd32f2720d54b5380b108676a9fc10bb620b8b2e41ca4ddebd811ee581f14b7adbc8dc7e01df812bf906a958bbfdc9dacbfccffa0119cf1640ce2cde64b67dd78829f285a881ce9ee709b7105e75d24b0dc23737f9b3bd5f26c62b50d5485ab0ac0bd9ebe81bceaa67e03ff9e07af9ffe538f27484837e3a87561abd6e281e785779e730d5031137707c0662265a42157e0ca1e22860d054b11e02f1c9789d73b9a73964e047cdf5a72871158a71019107b00e9a5001cc13fb683e9dc3e40c9d5a33d3d56c780da7e09b71b73f16c9ef529edea973c68b8ce4778f780ea22d9d691bbd8ed9316e50039f34cb53ff4107313316ccd25749116b89f78af9f9ec2a1aee569789959d42f9b4289d534a5a02022543c0806552dfdf259642e08fece84c0cac2e2d471ea106f7c88010e6b7752d0a279c1fc0d77bee30f01a5be93344949810d28133707f4d6a401678873a98b601aac24715f03f33a37ee6a81eb6a7c66fd262f335d33d76aef19ad8069f552ab348114c6f8ea7dcf6919a17e8dd4726ba2871d1712e1debe98596b646ef03459f189c7d670fb99210c7474494dd9d413f839f5c303d9da9f75c885f22c6918c8a7fd52739d1316bbdf9162d20ace9c0b38218ddc5cde578852c880457577c4ef8081d3cc8ce5f471f66dfc09107e8b6d1ddfe27a39830cd8e7c870f10b8aaac4b84349a6d76a0b55eacd3d35fc2a45ce369b09cc183517a6b45a18a7d6ff3ec753b04604c6a4e4b85e212201e3fb605414c23f49b9030a633afc1238023e14651135c60caa1c9ab61bfb0e4715a8d3ed529cb6c1dec871f78b5c6c246bcc231ec74af13e79f8898ee222dc58048bf973060dc58638081563dd629a73b9ab4eaed406ba2877db9dd0a092586fc977bda6a94d037e7432997d9a9b7737cf6b2790fee97e3bfbb5d71b8248c62410b4b704b039c05d6e55ca203c185495109972593046a83f382c4caecc386598b6e64782b7ad5a815c2c8ce7b1dcfe77e5276ea958970a91b39e33817da75e3ffd72426aeb22b5f5d0b513e0855da87f15e224334ad26515c9da755fc69d008377b9958589d671220fc5d7e08c75f3b56ce5a0c6b1f315c8a326014c3c94f4f52e5b075d65fd11afd457d7378d5cb5c1dc40bfc59629d0178e40e88a7b7994d57b086b8e2c170af3916d15894167eb0345db9fc84743cb20a4a383f1439932ff7bd87c72d82eb14997753","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e8c715baf66fc43d4fd6985279fc6def"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
