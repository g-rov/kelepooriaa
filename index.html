<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Site</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Site</p>
                        <p>Please enter the password to access this site.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c8024b14acbfa8dfb11122f973b71750e68a4aef31b825088b08370344065617fb4c9ff7febc3c41ed6009982fb0a9581b725aba043aad05d1db80eabedead57bd00a31d0f18d13acf034ef4cb4f26a759fe84984c0caf8367aa699bdf182f872e5a4bfeee4a45aba962df58c6997a757f6f9340edae63b0d731b1c8845b24e171ae6dbd365e00a87ff05f803ac16b350937cea308cb7bea40c5e89aad3c412193c62500c56e67f35e4c987865a27319fe59e8ccea8aebcdce89ec8a6bc50089f6b48b0a247f7b92a3aaa402d02beda7d6c56df1c49a8169c70921c4dc141e0a9a66ba140412b6f90efb9427b561d211b2fdc1e72b224f35bd2113e3f9282f1fb5d979281e99945c7ede9026832649a5f76438e0b3aa22755e2b6f114f98b9200ae8adca47c3c4c23206684bd4eb2ed38451807253ce26d591192ca1fca77fe7484229ca332d7e0632b38e0939f72099e50bb0dc2b77bc4c7662609558ea599e6acd5baf1de2f0524d69c57180ccdb28ed2815688dbfc33355789163184b6b9ab750ff884fa1ea91f03ad1cce20eba5a4f85587c2eae1b526ea718a40c83cf96e8dcc8f9c8f358b7b269140cca09ddcc057d42a07e90c89572ce5e10e4c4fc2b5af976b802483caca67c9c9be9dbed070dd6b097ab5b1e36d9443fc89276d9c9e7d7cdac9e8a849195ac0d09e3daa18e623507cce4d5cbb47b6e795cc8d9166a3948a6b551333244f279a61199e48138cf7c0fad722cae96a9c24961d5fda41eefe3b15b5a78dd019da71f11f82dffdb636ce51bf11a0294a520ee749a6402d93ee1f86bcaeef087e5aa1af48511a03d150ce10d18e1bd74cff85f8685c5f41e79638aabba662b6d6642a78dd8d95ddf82c4e64dd534c6056b591f3ce886a974a94f926e56d3a90ac3baa84f0134a9c368bfe04ed43b24797f8c3140878be1901bfa692ca2ffeef68eeecfd7fb905d1431c10d6a5c2184b64bd3c1b64fe28e089680ae906aa22f6f477dabbc311c11022dc35a62c8f6acf531aabfe680f3bca76393494eb30e55c51a1fcb6aefdad41c9d8940da07b343b831872666ae03c75ccd4a64e4a3934ac0b5e2ff447dfbb129a70aa9bf9d94422ecbc46eb996f330486925ecc2f892ff21b407572ae6feb20236756784fffd6467f0d45f3b1bbc95ba9e1715fff1f1f61f35c439fd0107eee5c9daa259471980095d6afeabca2ff35dbfb0ece9849b9a795681352450ba85a4a41b22381bcca5613d1dc2aa43fb1ab9c316cd873a5ae4b93056b05f7b095c4e39ae50c22e00da2cd8b7ca329f1a3fe235a1273e622e0aa09ef2e3e4b2ac1995d2450c1f7c5422772399dd4a00889bdaf7d63f703fc9b3c861ec828030e209fd42e745cf330865917792be8ef49d07b32cc9124a51f82573c8041281a01ea355c7bfee152a1ab4b56613425a30c80e03907210cfd6f24041e17dfc463ec012c7f092d47a49301f0c67924485af0f39806979607a55b2405dd16f8aaca57e8e014f81be80e98c75a158e1de9199b03bb197adcf0bc6d471d9bb2e7c15c3b316cc839d2c73540e1f70be32c95c30af3c3ac0d94f33137c6d1a0b1ba1593a54f294a27040682eac300e5279e937a43f954af2f249980af79bbe78e9eac219d1eacd321152703ebe5a50cec90f070f6d14491f4e501a330eda56a5f73dbebce74987f19aea3fc7147704b50beddb7124480840668abf01c1222aec26ec025404bd75632ba3a8ef745a6dca7c7d007ea97c90c137faef7e9e6c1400b71c436eb9ff6b9a2569520cf1fc5757db88228c342da47fd69716441f0786649c7b8e3c42a615cf600d305fe631feaa6dc6fc2e1cf86b7048db04a167c31ca5ce2455c1074ca481ad89f8cc07b138ef0e8e0d75256518e273dbabd7d50c7556cbdc26e23bf0145196bdbe4234e01191ec70afc4363b90608b04ea6b93bce06f5e5d723a610c37dfc51d28cdf83c6d9c11ce107e8345329f973523f73454f73c3e479a3560109849d7a223f5913379d2e91433883af2f4ca95b64739e9199b60b3cbb89e669fb0829cce26aa4791174c8a3f0ddcb19da7ae559c4407d8a4eea5c37723ce85d1e191c839a5835c131989e43c2a87b0886ba79222418c3f6e8d0c4a50d97ca0c2e259f8660564028775223a619166ca0ccf5431019ec9ba1c18829c5468189bf84279692d0ce9b2f9accb5357182c3165b84ba7f5cf1647b17c07011ab0b1d4ccbee60b6ef0aff1812f9ffcf98a3ecffb1171868e6294765e6ec6b7577986e1cfe8fef50d179301a64f08b661fa3c6cc268786326d7a4891e6fd72119d5a9a5fadcd12def0c05b2b7843bd106729251c1786761533a312ea7b02ada6d7805c77f0afeea78c12550f7793612a8cae43e325713a3a0e381a67608b8ccc2eab068f639db98e987f34d853a540ba188d0f0fa62e5aae22d51832cef381dced1124529e1a01120f66ad19763dcc4cdbb3ea63e472c96d7a2dac7247e76c8bb9a36eeaad3d48fec86b38e22b21ad93945d36add89c758b39ea4ff1d091f528b89bd6df01a404db2ecca3aff24a4243f61f016ebbea2591b8e8542be25d0083f20d3268b0da9ab7441fd85c77db19b4b27c2b11029dca609ae6d9bdc5ba406e5798a0fa76de9fdbe4bf01ce8781038ad0a8b08a10e4d5e58e49ff7ad13bcec332d90f97acd70c9b2d161e49770f114cd0d41e45d71fed7a1e5de8ae36025e8e9da677dd528e6cb2029d2cc68627ea25dcb930bbf7b8f81731c77dd3847dfdb887d8f17e80a917015d85c0dff1d0d45cec4683e6c12ab1df402b8d8b859cbf7bbc84c2419a7d67f55f109147f43d4256ce9f2e59b96c4a0f5474ec6093a0af3314bba0d9a3700c2a0e3712394ef5842c3e1639c008dd2e9a47c45cc6e1b5df2275c8e532da0f547d91a5186442e073fb5b5d8016aebc908f078fcc00f4664f62d5c38a8672b57c3a24e841e4e5ab697ff9a4edfa296e6ad19ef9610a783a97e54aeefd09e2ddb7bd00f3cb149eefe8b0e023e51e5dd321166d294b2e5706c1c43cdec1ecf52acd2181f5c2c49b695950385d4736d00a3830e18cc4095cceb7b9807fc294a3201e9cf80693941b4aa30db38a854e64faf4a2a7c9045901dc927e546750b12825e7787d89d2b5c3ba105c3e2ba62fd1899dbd47f779a2245c6cc0a947bdb3f97b98ababe491c1b4c4ead09d58fc00acdf6f43391eddaf7cff8e6dccc22852fc9a0efe880e3cf72fd8bdcba4dd5a0cc5350f3309611947e96c82f78f879f1cc7a2c54c62cb8530a8c5c85130622856191be13cfac4c906de2f6360a99dcaa16a3a49994177906b3987e68e778d87313940edd4406aa205b72dd5c3f00599719f619101e766835d3fd4a4e3b8178bc004afd5fba172b2f562688049465afa2918f4be5c6c487f76801ab977c56a80e5573871ca0e84d201a4f5bb9f81652fd0e90c740a35a057f339834d8a3ec316a6a2a4c668179f8e474cb4bedd7b2265b84431c7830b136daae2d70ea764c4a868bc7a1a0504b4d843e0e6ce7182aa526656f58ac0bcd2915b653cba7b4e857d325dc3d606c4f4bb0bfbba5fbe627f46ee88839f056f27ecbc651f7cd2bb8632a8e91453e14b285d4b8aefe0bbd30c292307e5888a3b1f60854f0bb0266952d0eea48ebe37eb7b68248fb212f1967b866ad5c304266b640c78239350f3d365e0c810bd0c6024eb1b93a716ba287943613c0ff82971f4a2b2957b4307c709941b747a0a37fa3d6ef900d37ccbe3223bb941bbacd730cf5f9f34b67f2d948ed9991bd77adcf59cafc4890110e0ed90df1edfed6d74deb62c2cafe5d14d2f48395fb7c9185345bef98424e82c85918d42effccd7ff590e1bb32a006f57acf1b13ec8932613c375a9bcf769b889fe2958e3d1ebe93b73f4fd70087992b68aa3f8c5a7c385ca8cdc3da8da1c1230f90211f75a9bf2d25e2d347f77f99957f932ea1347f72aed98cf049a6d3e6d3ab2585a97e6ed7910ea36c1225b39ab60e8e7c962d1f1b7bd2ba4dfea008ec04fd78e7883f9fa6f147af4098243994e876ef39379127758af69f0a56f73bf9db9f91d8e69fad337756e40d5cc9476badaa61d40899c37be2f2aa938feceb335e88d1f54613baa43dfa604e564bf6a8551721ef1d41202cce218570035e8e65a722081e2b525f54760ea9ae9606b18a5cb4cc7d8f448b8b3f2cd4e2ae7195ed646f035153628d0f645290a415a9b082e7063dc9f911786795a981530284bb34506adae82ccf8809e87c65cc8723dbce778a972bca420ebd1f60587aea85910d93aa648329f07a13c727c5096f2446f3d245317640df9064ec8d1de7162bb1281725ed08f93696fff0fd6008c9d1247eedf3e1c8f8b842fc295f4c19f2a111d7a5599d964e644c577c89f9a2d87389be6e73ec3a2dc2c0b64c1562b17d8ad370c153d53a592636c4937961769835577dc9588bd1d1ac38ff8462c0f9e710aa029bcec44256fa6038e1d9ada60913d54368e3ac3b7c5ebc4353fb6dcdbbaca093d10e2a75abe3709c6e9819bdb83fb803f5733e4c8720220a406d11ba5935ed48141a010a704230c27e06dde80404a15046765b0064a0e07f77be9f179f061d12513b5f170ea4100ee14147ad224dac304a000411579417676985d367ad2fdf89b66ce282f919d90c04ae10a26b399f4b9557fd653bdea84b1d21b6d30bf2c142b782e1a76afc25bd7c87788738babfa4cbd933b8a0d458431717b6221bef3e6120931e846b6eee95c29675981fe1da1d1bdb2ced210d2cc96592821e23b08839050cec528ddf28197d5ad50394c46e1e61eeff97636d727f62ae6237c081d2c2c9eb2b970fb34f17ba6c011413a60a1fa8d2cfd0b6808acb029f8f7035021df41f9b7b1faba6d0c4ba855783e3d2de47a331d68e4a0fcfedfd622899d1accc11b528c284868e6ca675e64b9b7bc812f902e607c08052dc3d4ff96346c3f53d75f173e110fd206d2428a6fa0f6013646d2ba326d2f5923746704cf4ef87d9256a17c6cf917df8f73332491bc9a10fd79bfb74f381737011814234f769a3aaf42aab3c668e40265809b1d880ace9e8725ea555ad48840b5e766defa6d1a0a3a8b1fa208a61af3563252355190fffb4d3b24f35de5b5c3027cb07911848a99c173d81b4dfd3ead31409ac9d81d4684ed1c64b2ad1925c716da7aa134e7aad778ce1d9ae363851d0e97abe1838c304b6debfd571750e499ed4c52e099ddff5abde95d8165aa30ef18acb8375cc6d4c08c3e661f9cdefe702e5027ea73171eaf7e500180c20a68ccc84dfda35e40e24f6bb732276eca0e92e6fd62bca87636a131f36a53344e43c958c8586ad6bcfc59c693199d0906056288e07f2f2e08a52d8bbb7c6cc8003d2a85b771d513a4458400053fa33bec5aa2f61ce166ccffb96fd1e43665af249d0e9b91020ec98df5e66d0912eee94f1559b3c2a673c84cf49125ec5bfbd45959f7a57c4dcb58d608cc8ef3bc4e8a7b6cbb3e3513d557f79c28a03e2fcb03a7ef407d0b5b23eac3f322c40c94ab4fd0e4c8640fa59eb9654f8ea3bd0b2fb3ecf8cd842392c4023a26914b4b3f916daaa567e19675f83c062d2f1ebba2ebdd9dc5462fc7fed9e9c0d180189845947c78994472facb876913045b2fbabce0ca2246b83e35c242564ea07321f898f554843a49f2b2cfab5020a13816fda576b51bdf95f70f44be27369c92a3466ea9b8e3c5d89c7f78c26cd5c7155ff8b66c671acd63883d63aaa536a0eb3d6a59b93af1e07a36ceb6f2144c082988b495c76c025b133df5cc9f742c3e02208ace1e19cf260c161058aa700fdd9984bcf89c555385df7b11b1bf346f300424feea11acb6d3bbb0e7c5c6bbd253a075f03cbc4e6e3ba166d3d5a668f2a99afac9c3938a321b8b82afda84e90f50a72c911891f09b0d433876a507598d6a27df31149164b06528c2af21ca403f0beaea22cba82051b6e3d70f80ff21d517f209d48a957c0ae3752539352e8ad7d8e9a3223f38ab5c16d3b307973c49b8c0d1ec35ede7e88b0541c48dba056c9e21f51b28303687052a682f9e1604a740541ebf1e749095dded78fe61d20d2b9e8dbd710f3c00be84a066b94691a4e90d48fd69d2ecd14915833e47c923c6d682e548810d190158bf52e2a122660c54e4ccb521c81d923ec73ae1a74530b3cb81ee18991172f54ef34e0da30df3d0c7c66b71c390c2cec912a5ddfb2d1fd6e412dac1ca87ffb097a95fe5434900938cc8b708261a67d9adfdd2a5c172797c807687d533ecedd26816c20991df7065926d6540b4445957d70f3926b1cf4b8142095e948acd2a54f87e1313b8c174697ab934f3a3ecaa8a0edf5d9ae956512081bc1659996a0c873c0a17df9dbae49ca9e9a5f8ace554a9655d25b87b4bbad2c93432cf61f59ed027e659f1280c375f71aaf01ed17c0f75bd23c4117515f1a3a4787477663529efb8d1ef1150a0e1060df4b32c95acae3f65d8a8b878d60206c588dcfc4f4a3a9999d1fbef5d9e55357d28f9416e4b02ee973493632066c6a1527ae9d221d68a59d2e86bde19d6cb7881f550a86bea22b1305305a479627197b140381123ff634c68e685590f067e2489560851ec1692e0037eda90ad3e433e7e19e8f9cdce5a36c9932a2b1899f6c99dff71e49cd961659a8f3bbee7626e166760f7bef3bda3d17e90c18424939e1b5788a0783b45969499751f8f348fd963a2ed3475a06c7994fefbe0b8aa0eeb7a0ed51086ba4bf8f7c10a990aeb2912ac02a9acde6ff21823490959c1f7d61ab37fecdf3a5b5c2889dbaf9a2ed0d713f4baa6ebcbe01d045b1ee9e4be231805ee58b34d6f1d7fea4aa6094e3472dc6fc4c9c23b075ffc1d875f58c8cb90108085d7b35f8e31ed95b862af8d15c2d0840126f9fad204fe68c7f0cc8ec1a65c108efdfcdb46519b6525577b1542f224c7fae5bbb5f539643b3819ad2d9a97cdf8526b4404dcc210827f78d4073675536c8bf3cda6d3b0f0ad92c872aa0657bc33d952f545650b8d082c53d0a171ed45bcb65d5c19363d85f63bcbc638e5677ee36cab8009ba2558327a7b676dbf96d225aa1cec666f022fd2fd5469833609c28951fa0cc9049255c4d25ad6abc20085f83899f50998e64acada30a1005dc55c706e23e163f496b0c2275219035e7d059b13e07eef42c189cf3464675950bda20311a876b404b0adb21809b9b765aee4e65e9a8107a86a09fd22590432bf36fe42a29aafdfa48218b807b2a090df37febd7c65e2f7992c28245c5d35c211e1cd2e9d89008c579021d0c0f4a380866c6f9ba676303a9a56b7e81f20f6ba16adf119dcced832f6f2e42705328b847639c70f0473869961fe4a4c7a6129b365716cd3e2b2a22e07370f7d0cc186215364cc341fd4675d3913b9b63ef46f3ad2b6148705de54ca9b08702c1fa1fcd5ff99ea45cdc0f2f29b58d857850fd238e89e44e2df3688b0482b13c1d665566f02084d733d21f8b040daa203ee4127098875928adcecec559f1cb1867535702233ad1881d66b8fd6d6ed629da696e5a2be65c4eb270e302bbf935f0d38b3ad9c11767950bc0bbac9d382b09453db22f63db87c0ed20eedf1641b2930ceb0fe1072a6e108bc63ad9128ff1dc10001d5089bb3deb8358673265acc292530aeacdde6c5e6c6af87541194411b3eb672cd081f82b4207edcc939f8b7bed6b19fbca6a3064795c9ae7f1b169a1d6864d8bac05513daf79166f3f13fdf1054af37b79a5751221f55ed6e04f4f4cd0e231565da2d5e7bbf8cc2bdaa5055b8c987080f0e20cf9f9b5221395b15576b60120c4c3b40552293cefee8a00d6f9e0ec9c156edcb55514a76f7b7f36bd4a7249fa680623399cad979115252a6140f65af9a3c0ceffe3ba8e30541a86d8f6796c5ca2691455396049fa09fbdfa0de924cdd13460f12de053fc46d9550e2534adf2cd788c30b239a8b201196d82369ce3740c5709e352b1e987ddf964349718c8c5d70702aed71c91fa7c6d784fe04a30a19ba4feb0bb1d2f43060bc011330f1e1517aec4d2600a6685afeb348e82b5c38793fca9bacafbaa23993932d9381a5067e3a842a0681bbb4bae7947b3495babb9ef41c35bff32e34d422e0ecd909cd2e2b0839df8ec98f004682168264f1f4b6a33328a8e991ea459811f9e7413ac39fb1816d6965dd170ea2eda5070cc853597498ce3815f19de5b996ea8dd8f7d05e5c10b59d562253e1c7ea756a153b5e363f06215bd67e2bda2ce44f3ac79c50117a2db04291fbc79bc9b88771a37692c485a977ce610aa8c3503cc676e77b87f052d78f7f3e817063e20c688efc5692b9702ad2b990b3b86f8906b21fdf613cb2cd2ec6053d98c502630ddee8282da6227421b91778ca1aa14c5e78519467115a436e3fdd29d4028ad8d21b399e1d19d2cee486751130e357e0adf47a378eeca6e7f6b3982f9f5e847c00c8a4f1c3a4a0cf47adbf1d822723bb9efa163495d37c71940d9ef21a84318b20a738ec352d9f72234ba46e9355f4731e21b3a93358b1efdb39deb40572f7f5e4bf05960724e819b4eeeec9a86751772b7ac381dea86170d580a44eba5d377e08a03ac8457eb6b9db2b4d1d937ad1f13446527f094a7b567748f3f7f63f90cf1729cf4f115459538e03e9d1c4dba00dffd3b0c7106366018dd5530250a350aec751caa620fd8d0dfb473efd775eedc857166a3a4dc7131a34074615b082357c9b50b65c35f9867dbfc068e02a39f6026dcc959ee37f057f68aa94fb5ebfdf6ef29f6a269492776f199ee32439ba5c6231b822d097f063864880abf7ee9d7aa01f753b33d649e319ab0dcc6230a42938b734b6f36fc9c7dd332353846db145d902aaa18d260aa98f8dce6090b254f7ef793c89be51af647dad6706ee9fa1ee317fa8e4e494c5550abcbe7faea1cd62c41194aca940e3c2bf540616fa7983c34f43621b8b8d74925ad729e29c32e5587cb3ed53c3fdd69e62735503a72332f0bb5a2e6925521adb7c3abd03369a0023d6697f7c0c2e94bda3bd79e92bdfa14da8f19cfb6b24c01c336609e68cbc3c92efc0ef75376664a99d11f827b424e46f837d6cfbd969cc44949f285482478fdd15cde3f6062c54c973af8063472ddfbfa32393b4f44a092f7b02e547ed1f1d0cc2f5fa673ed9a03d83662018d0601fd2634d61cdb2f142bfe62da75e55ee6f0551dd6be656e2e6664308c4d105fdfc345fbd76147c65eb1f1aa1ab307340de25342f1c30cae83864d0009eff250238dfddc2e69c406ff702cea80171774043c545471d847e2333ba7039da9c70786fe0471b3ec63f0697aeae5dfb0df93dad92908b891f112b89e01dc17b1b05681716f6f3e88bd2588e98613b5dd443784cdac2606ec2172dd1402b70e323a6c2b0b9fc8f19930cda5fc48268adcddbb03733f70b106365ddbc080fa0a022b2e07bcd4d2c51d936e84cac6fe62b73ba67aa27057a1d2124ada5ecf9c46286bbc9ac838db1d1badf94a511432549d29e5b620ab1b4a7d298237c92e3c63c37d4637cb263dbdf987431394457e8777bddee228aab39ef97fe881cda6bb55a19ddfe72b17d1d53c617509f383b80a5e59d09fb3b020ac1678171ad0705180bd0304f44a231080937a0fb3e537002e008dbc801d51b8fca46de0e4489c68e29468a354d0facb0250ce6acc3a91e7e5282069f6126998f25b7c8b2850c1c0737061dbee944ee5c5198f3a0bba3adf5a76f76ae1307a79866baf165e2d4f4bc467dda78f2794f308a82360548dbccc49b2839d69c77a8c524d494dcd166add85d7953205ea4aeccbdb5cb876132849c52dccff80ba46149fdfe477688be80529475b4cd15d1b638c5c61055b8a2f3779f68009645a9771eba3ae83dd331fd497dcce3c4a3c0e628eb90ad8d3dbdc15b8dcd1578f6944cc48317902bef68ac62716f2a9ac7237fe85d4471933a9bdf0365f7b5fa331878e5211778b83b39f07de3960a862b784a435aff3f6912e982d4c1d749033e9cae9946a63870c07fc5d6306f32930cc33670a69efb25e70f7028fd1c2017f49ac0f79a5bb7c040f880f79a6952eb7b10caa88773ee65c3ec6ba7dce87873af5fd2272a297ba314c953902650d26d9af241a340913adcddac3269b17c2f754900f4142084dd18f8f9038e1b97d481ece36b06b4b6fc010811c6b631c7529338e4bf11e4dd3b1193b556a7908aa8184640f9eea303adbf7ce1a768fc11336ea4b2d15d7cd9c14329b5d3e67a2b741d15a9c638d138d2d1ed1a8a6deba77ab2a0739d89617e62eecee87fdcb0ef1f5f2665e89009f9e42666d4c42ea667e3228c679cc7aa0b651072d61e0f201ecbc1b55f6ea2ce1b6ea2d92a0ad9d436f31e33ac9acbf4650adee324d4ad31acc91e37a7eafe51085b6703248e31ed538135ed3bd1568159409be17e0a88c2915f2ba3889d7827a5556799862c2cd0e8e91a6061ef795cdef1bc90b4e414afe529f3cecfe05f60375721fb0b8c1e67f48cfd3a5e29da63ac425efda063bea3b0959043eeac97ad5f99f68995ac1fa43dce9dfdaad25580bd01c572de5d10993f85d642f8af5cf6063af367302332df41663520e814c3766682ba7ca1e0981574a277eb3fff34ffee62d5839b1355468b7780ae8297ea45462f566568e2a3d8b25277647588b226a36a51f8928d529d9df6f8753458e65676e7900202d166064f17901e571ddd4a2fb551906b951dff6d17fe9643952766bdad18e11d6d13e7cc50e168fc191bed3756ae08d113cddd595cd777ff51c40bdc3796ab7c6107f11277d03d4082edd27eae26687c874905c9cc44487d9ed8640bc91fe59c8197d4d28ba67578f643c01f05735fa9f96dfbab2a28b5669851a4af2373f1153a95652dfce65507739a4e99ccbb7d192530b672abee8f70c05882c0c747b10961e7251ea5a1195ddb61d3e6dc4e764faa9feb765a47c62ccae7c70fd64a31fca700b7bd1a7c6267cf15cba4abc95d2a84eefc5ad2d294b2d3622d697aef858975e142446200823592e0d3a4c97bc1d5247bddb05b3f13924ad87d0f01a3101b7bd28602665d4f1e519fb1ace1baf155e1fe4500ed3a9a9661764d5b35344c05a34fc964fde66e3767a702c5813d0c28ca0cc04e77f59f824fef2ef3d68e428cfece35cb46a9ecc597ce81bc112e9de5bf34a7d230a4f1481719b778442093113e0007aabf6d9d70a80ba21896c18edc63c5fd23394ba3cc45d8a41d5de4f60aa6aecc05319d42f5db504085502bc11a4443034ef1d9e07d6508eaa053d56f4c58d93b95ea634931fd086517441f3885143953ba7e85b88dab17a55c64b08196f330d86881c6bd0f4cef2096a8c7d889565d431fb0f37b4f0adc94732049b65fd593ead8297a51457ced32b9f5e4e766e63d01d53f03ea3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b3237fcae92bf6834c56de4e107ae77"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
